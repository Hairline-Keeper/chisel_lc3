# LC3-Userguide

## 一、项目介绍

Chisel_LC3项目设计用于计算机体系结构课程的进阶教学使用，项目使用chisel作为开发语言，实现了基于LC3指令集架构的简单处理器。

LC-3全称是[Little Computer 3](https://en.wikipedia.org/wiki/Little_Computer_3)，是一种用于教学的指令集，其特点就是结构简单，相比于x86这类复杂的指令集来说，更容易实现，又具有指令集基本的功能，能够编写较复杂的一些汇编程序。使用LC-3能够更好的将精力集中于处理器处理执行指令的流程中，而不是指令集本身。

[Chisel](https://www.chisel-lang.org/)是一种硬件设计语言，是在[Scala](https://www.scala-lang.org/)语言中添加了硬件构造基元(Hardware Construction Primitives)，能够通过编译生成可综合的的Verilog代码，其相对于直接使用Verilog，chisel生成的电路能够更好的参数化，对象化，使其在编写的过程中能够更多的使用面向对象编程的思想。

本项目中LC-3的实现是参考[计算机系统概论](https://book.douban.com/subject/2185076/)中的LC-3实现的，目前已能够在计算机上仿真运行，终端和异常控制部分暂时没有实现。

## 二、环境配置

**Ubuntu**

系统使用的是Windows10 WSL，Ubuntu 20.04.1 LTS

**mill**

[mill](http://www.lihaoyi.com/mill/)是用于Java、Scala的项目构建工具，项目使用的mill版本是0.7.4

在终端运行如下命令能够安装mill，如果下载失败可能是网络问题，请多试几次

```shell
sudo curl -L https://github.com/lihaoyi/mill/releases/download/0.9.4/0.9.4 > /usr/local/bin/mill && sudo chmod +x /usr/local/bin/mill
```

在安装成功后运行

```shell
mill version
```

下载完成后看到mill版本号即表示安装成功

**Verilator**

[Verilator](https://www.veripool.org/wiki/verilator)是一个开源模拟器，能够将verilog代码转换为C++代码，在系统上进行仿真，模拟硬件运行时的情况。verilator的安装很简单，只需要使用apt工具下载安装即可。本项目使用的verilator版本为4.028

```shell
sudo apt install verilator
```

安装完成后运行

```
verilator --verison
```

看到verilator版本号即表示安装成功

**LC3AS**

这是一个简单的汇编语言翻译器，用来将LC3的汇编程序翻译成机器指令，你可以显式地调用

```
lc3as [asm file]
```

来生成汇编程序对应的二进制指令文件，但实际上在仿真时通过IMAGE参数指定名字，在编译时会自动调用lc3as翻译指定程序

## 三、编译流程

仿真运行的编译流程如下图所示，首先使用mill将chisel代码编译成verilog代码，再用verilator将verilog代码转换为C++代码，编译生成一个可执行文件，运行这个可执行文件即可模拟硬件运行的结果

```
+------------+    +-------------+    +---------+
|            |    |             |    |         |
|   Chisel   +--->+   Verilog   +--->+   C++   |
|            |    |             |    |         |
+------------+    +-------------+    +---------+
```


虽然从编写代码到真正仿真运行需要经过上面的流程，实际上在Makfile文件中已经将所有的命令写好了，想要运行项目只需要在项目根目录下执行

```
make emu
```

即可。但是要想完全了解编译流程，推荐去阅读Makefile文件和相关命令的手册，了解相关参数的作用，下表给出了Makefile文件中一些关键变量的含义

| 变量      | 作用                                                         |
| --------- | ------------------------------------------------------------ |
| TOP       | 编译生成的verilog文件名                                      |
| BUILD_DIR | 项目构建生成文件所存放的目录，例如生成的verilog文件就存放在这个目录下 |
| TRACE     | 是否生成调试用波形                                           |
| IMAGE     | 指定仿真要运行的程序名                                       |
| IMAGE_DIR | 程序文件存放的目录                                           |
| LC3_AS    | lc3翻译器所在的路径                                          |
| EMU       | 生成的仿真可执行文件的文件名                                 |



## 四、LC3工作原理

## 五、各模块功能

**DataPath**

数据通路(DataPath)包含了与指令处理相关的所有部件，包括寄存器堆(Regfile)，译码逻辑(Decode)，算术逻辑单元(ALU)，总线(Bus)，以及一些选通逻辑。数据通路的设计参照了计算机系统概论中的图C-3。

*Regfile*

寄存器堆中有8个能够存储2Byte数据的寄存器，大部分程序都是通过对寄存器堆中的寄存器做操作来完成的，由于一条指令最多有两个源寄存器，一个目的寄存器（比如ADD A2, A0, A1，从A0，A1寄存器中读出数据做加法，将结果存入A2寄存器），因此寄存器堆设置了2个读端口，1个写端口，每周期最多能够从中读出2个数据，存入1个数据

*Decode*

这部分用于将一条2Byte的指令中各个字段的含义拆分出来，分解成操作码，寄存器号，立即数等信息，用于之后指令的执行，具体不同指令的字段含义，项目参考了计算机系统概论附录A的LC-3指令集结构

*ALU*

ALU是最基本的模块，用于做数学计算以及算术计算，纯组合逻辑组成，有3个输入口，2个输出口，ALU接收2个操作数a，b，有四种操作，分别是

| 操作                                     | 操作码 |
| ---------------------------------------- | ------ |
| a加上b，如果最高位有进位，c为1，否则c为0 | 0      |
| a逻辑与b                                 | 1      |
| a取反                                    | 2      |
| a直连输出端，不做任何操作                | 3      |

*Bus*

在不同的时刻会有不同的组件发送数据，也会有不同的组件接收数据，如果所有的数据传输都需要一一连线，代码逻辑会变得混乱且冗余，因此在项目中实现了一个最简单的总线。总线宽度为2Byte，所有需要发送数据的组件都将其输出端连到总线上，同时相对应的每一个组件有一个控制信号共同形成一串独热码(One Hot)，总线通过检测控制信号中的哪一位为1，来决定使用哪一个组件的信号作为输出。而需要接收信号的组件只要连上总线的输出端，就能够在正确的时候获得想要的信号。

**Controller**

控制器(Controller)内部实现是一个状态机，通过生成不同的控制信号，配合DataPath中的选通逻辑，能够控制各个处理单元在“特定时刻”做“特定事情”，直至指令结束，在主流处理器中，是通过将不同的任务进行拆分，每个流水级做特定的任务，使用流水线的方式工作的，在LC-3中简化了这个逻辑，通过控制器给出不同的信号来决定DataPath这周期需要做的事情。相对的，不使用流水线的代价就是LC-3只有当一条指令执行完了之后，才能够执行下一条指令，执行效率低下。控制器的设计参照了计算机系统概论中的图C-2。在控制器中有一张信号表，通过状态机当前的状态来索引这张表，得到的就是数据通路中所有选通逻辑的值，通过状态机和这张表就能够控制数据通路在不同的状态下做不同的操作。这张表是在[开源项目](https://github.com/mdrush/LC3/blob/3026928d98d2535ae62f7fbe21aac3610cbca7c4/cs/controlstore)的基础上修改的。

**Memory**

内存(Memory)是处理器用来存储指令和数据的存储单元，在真实的电路实现中使用一个真正的RAM模块，连接上对应的信号即可，但是在仿真中我们需要使用DPI-C(Direct Programming Interface-C)，这个接口能够令verilog仿真中调用C语言中的函数，来实现一些特定的功能，在本项目中我们用来对Memory初始化，将需要运行的程序和一些TRAP程序初始化到Memory中指定的地址上。在有了相应的verilog模块后，在chisel代码中继承BlackBox基类，令这个verilog实现的模块可以在chisel中例化并调用

**Uart**

一个处理器和外界交互最重要的就是输入和输出，而Uart是最常用的一种通信协议，项目使用的Uart模块是在开源项目[[1]](https://github.com/huangruidtu/chisel-uart)、[[2]](https://github.com/nyuichi/chisel-uart)的基础上修改的，这部分功能在仿真的时候也是使用DPI-C来模拟现实硬件中Uart的输入输出，在仿真运行时模拟Uart输入的C函数会定时检查在终端是否有键盘输入，如果有的话会将输入暂存到一个缓冲中，每次Uart只能将一个Byte的数据传给LC-3，并且只有当LC-3接收了这个数据后，才能够传送下一个数据；模拟Uart输出的C函数会定时的检查LC-3有没有需要输出的数据，如果有将其打印到终端，并告诉LC-3数据已经被接收，可以发送下一个数据。

## 六、调试

在Makefile文件中有一个变量TRACE，默认是空值，如果想要生成仿真的波形文件，需要将TRACE的值设置为 -t，则在运行之后会在build目录下生成emu.vcd波形文件，使用[GTKWave](http://gtkwave.sourceforge.net/)打开即可看到波形用于调试。
